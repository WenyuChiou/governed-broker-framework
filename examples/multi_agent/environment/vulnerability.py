"""
Vulnerability Calculator with Depth-Damage Curves.

Implements FEMA-style depth-damage functions for residential structures.
Supports both structure and contents damage calculations.
"""

from __future__ import annotations

import logging
from dataclasses import dataclass
from typing import Dict, Optional, Tuple

import numpy as np

logger = logging.getLogger(__name__)

# Conversion factor
FEET_PER_METER = 3.28084


@dataclass
class DamageResult:
    """Result of damage calculation for a household."""

    depth_m: float
    effective_depth_ft: float
    structure_damage_usd: float
    contents_damage_usd: float
    total_damage_usd: float
    structure_damage_ratio: float
    contents_damage_ratio: float

    @property
    def total_damage_kUSD(self) -> float:
        return self.total_damage_usd / 1000.0

    def to_dict(self) -> dict:
        return {
            "depth_m": round(self.depth_m, 3),
            "effective_depth_ft": round(self.effective_depth_ft, 2),
            "structure_damage_usd": round(self.structure_damage_usd, 2),
            "contents_damage_usd": round(self.contents_damage_usd, 2),
            "total_damage_usd": round(self.total_damage_usd, 2),
            "structure_damage_ratio": round(self.structure_damage_ratio, 4),
            "contents_damage_ratio": round(self.contents_damage_ratio, 4),
        }


class VulnerabilityCalculator:
    """
    Calculate flood damage using depth-damage curves.

    Uses FEMA-style curves with 20-point interpolation.
    Supports First Floor Elevation (FFE) adjustment.
    """

    # Depth array in feet (20 points from -1 to 15+)
    DEPTH_POINTS_FT = np.array(
        [-1, -0.5, 0, 0.5, 1, 1.5, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
        dtype=np.float64,
    )

    # Structure damage percentages (residential, one-story, no basement)
    STRUCTURE_DAMAGE_PCT = np.array(
        [
            0.8,
            1.575,
            5.375,
            9.775,
            14.3,
            21.8,
            28.7875,
            40.7875,
            49.1625,
            55.9625,
            59.5,
            63.5875,
            66.95,
            67.1875,
            70.3,
            73.425,
            77.575,
            80.725,
            85.025,
            86.75,
        ],
        dtype=np.float64,
    )

    # Contents damage percentages (averaged from 1996, 1997, 2005 curves)
    # Original curves from FLOODABM modules
    _CONTENTS_1996 = np.array(
        [0, 0, 0, 23.9, 33.4, 39.8, 49.7, 65.6, 67.7, 73.25,
         73.25, 73.25, 73.25, 73.25, 81.85, 85.95, 89.15, 90.65, 91.85, 91.85],
        dtype=np.float64,
    )
    _CONTENTS_1997 = np.array(
        [0, 0, 0, 49.225, 57.625, 62.35, 67.375, 78.575, 82.075, 83.7,
         84.8, 84.975, 84.975, 84.975, 84.975, 90.275, 90.875, 91.925, 92, 92.175],
        dtype=np.float64,
    )
    _CONTENTS_2005 = np.array(
        [0.05, 0.35, 18.45, 27.75, 33.15, 37.05, 43.85, 53.975, 61.525, 66.525,
         72.6, 73.55, 74.3, 77.325, 77.325, 79.275, 80.35, 81.275, 81.95, 82.125],
        dtype=np.float64,
    )

    CONTENTS_DAMAGE_PCT = (_CONTENTS_1996 + _CONTENTS_1997 + _CONTENTS_2005) / 3.0

    def __init__(
        self,
        ffe_ft: float = 0.0,
        clamp_depth: bool = True,
    ):
        """
        Initialize the vulnerability calculator.

        Args:
            ffe_ft: First Floor Elevation in feet (offset from ground)
            clamp_depth: Whether to clamp depths to curve range
        """
        self.ffe_ft = ffe_ft
        self.clamp_depth = clamp_depth

    def calculate_damage(
        self,
        depth_m: float,
        rcv_usd: float,
        contents_usd: float,
        is_owner: bool = True,
        ffe_ft: Optional[float] = None,
    ) -> DamageResult:
        """
        Calculate flood damage for a household.

        Args:
            depth_m: Flood depth in meters
            rcv_usd: Building replacement cost value in USD
            contents_usd: Contents value in USD
            is_owner: True if owner-occupied (structure damage applies)
            ffe_ft: Override first floor elevation (uses instance default if None)

        Returns:
            DamageResult with damage amounts and ratios
        """
        # Convert to feet and apply FFE
        depth_ft = depth_m * FEET_PER_METER
        ffe = ffe_ft if ffe_ft is not None else self.ffe_ft
        effective_depth_ft = depth_ft - ffe

        # Get damage ratios from curves
        struct_ratio = self._interpolate_damage(
            effective_depth_ft, self.STRUCTURE_DAMAGE_PCT
        )
        contents_ratio = self._interpolate_damage(
            effective_depth_ft, self.CONTENTS_DAMAGE_PCT
        )

        # Calculate damage amounts
        if is_owner:
            structure_damage = rcv_usd * struct_ratio
        else:
            structure_damage = 0.0  # Renters don't own structure

        contents_damage = contents_usd * contents_ratio

        return DamageResult(
            depth_m=depth_m,
            effective_depth_ft=effective_depth_ft,
            structure_damage_usd=structure_damage,
            contents_damage_usd=contents_damage,
            total_damage_usd=structure_damage + contents_damage,
            structure_damage_ratio=struct_ratio,
            contents_damage_ratio=contents_ratio,
        )

    def _interpolate_damage(
        self, depth_ft: float, damage_curve: np.ndarray
    ) -> float:
        """
        Interpolate damage ratio from curve.

        Args:
            depth_ft: Effective flood depth in feet
            damage_curve: Damage percentage array (0-100)

        Returns:
            Damage ratio (0.0-1.0)
        """
        if self.clamp_depth:
            depth_ft = np.clip(
                depth_ft,
                float(self.DEPTH_POINTS_FT.min()),
                float(self.DEPTH_POINTS_FT.max()),
            )

        # Linear interpolation
        damage_pct = float(np.interp(depth_ft, self.DEPTH_POINTS_FT, damage_curve))

        # Convert percentage to ratio
        return damage_pct / 100.0

    def get_structure_damage_ratio(self, depth_ft: float) -> float:
        """Get structure damage ratio for a given depth."""
        return self._interpolate_damage(depth_ft, self.STRUCTURE_DAMAGE_PCT)

    def get_contents_damage_ratio(self, depth_ft: float) -> float:
        """Get contents damage ratio for a given depth."""
        return self._interpolate_damage(depth_ft, self.CONTENTS_DAMAGE_PCT)

    def estimate_annual_expected_loss(
        self,
        rcv_usd: float,
        contents_usd: float,
        flood_probability: float,
        expected_depth_m: float,
        is_owner: bool = True,
    ) -> float:
        """
        Estimate annual expected loss (AEL) for a household.

        Args:
            rcv_usd: Building RCV in USD
            contents_usd: Contents value in USD
            flood_probability: Annual probability of flooding
            expected_depth_m: Expected flood depth when flooding occurs
            is_owner: Whether owner-occupied

        Returns:
            Annual expected loss in USD
        """
        if flood_probability <= 0:
            return 0.0

        damage = self.calculate_damage(
            depth_m=expected_depth_m,
            rcv_usd=rcv_usd,
            contents_usd=contents_usd,
            is_owner=is_owner,
        )

        return damage.total_damage_usd * flood_probability


def calculate_flood_damage(
    depth_m: float,
    rcv_usd: float,
    contents_usd: float,
    is_owner: bool = True,
    ffe_ft: float = 0.0,
) -> DamageResult:
    """
    Convenience function to calculate flood damage.

    Args:
        depth_m: Flood depth in meters
        rcv_usd: Building RCV in USD
        contents_usd: Contents value in USD
        is_owner: Whether owner-occupied
        ffe_ft: First floor elevation in feet

    Returns:
        DamageResult
    """
    calc = VulnerabilityCalculator(ffe_ft=ffe_ft)
    return calc.calculate_damage(
        depth_m=depth_m,
        rcv_usd=rcv_usd,
        contents_usd=contents_usd,
        is_owner=is_owner,
    )

def depth_damage_building(depth_ft: float) -> float:
    """Building damage ratio from depth (fine-grained FEMA curve)."""
    calc = VulnerabilityCalculator()
    return calc.get_structure_damage_ratio(depth_ft)


def depth_damage_contents(depth_ft: float) -> float:
    """Contents damage ratio from depth (fine-grained FEMA curve)."""
    calc = VulnerabilityCalculator()
    return calc.get_contents_damage_ratio(depth_ft)


class VulnerabilityModule:
    """
    Calculate damage from hazard exposure using fine-grained curves.

    Input depth is in feet to preserve existing MA interfaces.
    """

    def __init__(self, elevation_height_ft: float = 5.0):
        self.elevation_height = elevation_height_ft
        self.calc = VulnerabilityCalculator()

    def calculate_damage(
        self,
        depth_ft: float,
        rcv_building: float,
        rcv_contents: float,
        is_elevated: bool = False,
    ) -> Dict[str, float]:
        effective_depth_ft = depth_ft
        if is_elevated:
            effective_depth_ft = max(0.0, depth_ft - self.elevation_height)

        depth_m = effective_depth_ft / FEET_PER_METER
        result = self.calc.calculate_damage(
            depth_m=depth_m,
            rcv_usd=rcv_building,
            contents_usd=rcv_contents,
            is_owner=rcv_building > 0,
            ffe_ft=0.0,
        )

        return {
            "effective_depth": round(effective_depth_ft, 3),
            "building_damage": round(result.structure_damage_usd, 2),
            "contents_damage": round(result.contents_damage_usd, 2),
            "total_damage": round(result.total_damage_usd, 2),
            "building_ratio": round(result.structure_damage_ratio, 4),
            "contents_ratio": round(result.contents_damage_ratio, 4),
        }

    def calculate_payout(
        self,
        damage: float,
        coverage_limit: float,
        deductible: float,
        payout_ratio: float = 0.80,
    ) -> float:
        covered_damage = max(0, min(damage, coverage_limit) - deductible)
        return round(covered_damage * payout_ratio, 2)

    def calculate_oop(
        self,
        total_damage: float,
        payout: float,
        subsidy: float = 0.0,
    ) -> float:
        return max(0, round(total_damage - payout - subsidy, 2))
