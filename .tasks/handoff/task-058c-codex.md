# Task-058C: Drift Detection & Social Norms

> **Assigned to:** Codex
> **Priority:** P0 (Build First)
> **Depends on:** None
> **Branch:** `feat/memory-embedding-retrieval`

---

## Objective

Implement population-level and individual-level drift detection to monitor simulation validity. Also create role-based permission enforcement for agent types.

## Literature Reference

- **AgentSociety** (Zotero: `KBENGEM8`): Population behavior tracking, 10k agent simulation
- **Hung & Yang 2021** (Zotero: `5I6XWJGF`): Agent behavioral categories (aggressive/conservative/myopic)

## File 1: `broker/components/drift_detector.py` (NEW, ~140 lines)

### Dataclasses

```python
@dataclass
class DriftReport:
    """Population-level drift analysis."""
    year: int
    entropy: float                              # Shannon entropy of decision distribution
    dominant_action: str                        # Most common action
    dominant_pct: float                         # Percentage of agents choosing dominant
    type_distributions: Dict[str, Dict[str, int]]  # agent_type -> {skill: count}
    alerts: List[str]

@dataclass
class AgentDriftReport:
    """Individual agent drift analysis."""
    agent_id: str
    jaccard_score: float                        # Recent window similarity (0=diverse, 1=identical)
    construct_changes: int                      # Number of PMT construct changes in window
    decision_variety: int                       # Unique decisions in window
    stagnant: bool                             # True if jaccard > threshold
    alert: Optional[str] = None

@dataclass
class DriftAlert:
    """Alert generated by drift detection."""
    year: int
    level: str                                  # "WARNING" | "ERROR"
    category: str                              # "population" | "individual" | "type"
    message: str
    details: Dict[str, Any] = field(default_factory=dict)
```

### Class: `DriftDetector`

```python
class DriftDetector:
    def __init__(self, window_size=5, entropy_threshold=0.5, jaccard_threshold=0.7):
        self.window_size = window_size
        self.entropy_threshold = entropy_threshold
        self.jaccard_threshold = jaccard_threshold
        self.decision_history: Dict[str, List[str]] = {}
        self.construct_history: Dict[str, List[Dict[str, str]]] = {}
        self.population_snapshots: List[Dict] = []

    # --- Population-level ---
    def record_population_snapshot(self, year: int, decisions: Dict[str, str], agent_types: Optional[Dict[str, str]] = None) -> None:
        """Record decision distribution for a year. decisions = {agent_id: skill_name}"""

    @staticmethod
    def compute_shannon_entropy(distribution: Dict[str, int]) -> float:
        """Compute Shannon entropy of a decision distribution. Returns 0.0 for uniform, higher for diverse."""

    def detect_population_drift(self) -> Optional[DriftReport]:
        """Analyze latest snapshot. Returns DriftReport or None if no data."""

    # --- Individual-level ---
    def record_agent_decision(self, agent_id: str, decision: str, constructs: Optional[Dict[str, str]] = None) -> None:
        """Record an agent's decision and PMT constructs for the current year."""

    def compute_jaccard_similarity(self, agent_id: str) -> float:
        """Jaccard similarity of recent decisions within window. 1.0 = all same, 0.0 = all different."""

    def detect_individual_drift(self, agent_id: str) -> Optional[AgentDriftReport]:
        """Check individual agent for stagnation or sudden reversal."""

    # --- Alerts ---
    def get_alerts(self, year: int) -> List[DriftAlert]:
        """Run all checks and return any alerts."""
        # Population entropy < threshold -> WARNING
        # Dominant action > 80% -> WARNING (echo chamber)
        # Individual stagnation (jaccard > threshold for N years) -> WARNING
        # Type-level uniformity (all agents of one type same decision) -> WARNING

    def summary(self) -> Dict[str, Any]:
        """Return summary statistics."""
```

### Shannon Entropy Formula

```python
import math

def compute_shannon_entropy(distribution: Dict[str, int]) -> float:
    total = sum(distribution.values())
    if total == 0:
        return 0.0
    entropy = 0.0
    for count in distribution.values():
        if count > 0:
            p = count / total
            entropy -= p * math.log2(p)
    return entropy
```

### Jaccard Similarity

```python
def compute_jaccard_similarity(self, agent_id: str) -> float:
    history = self.decision_history.get(agent_id, [])
    if len(history) < 2:
        return 0.0
    window = history[-self.window_size:]
    unique = set(window)
    # Jaccard = |intersection| / |union| of consecutive pairs
    # Simpler: 1 - (unique_decisions / window_size)
    return 1.0 - (len(unique) / len(window))
```

## File 2: `broker/components/role_permissions.py` (NEW, ~60 lines)

```python
from dataclasses import dataclass
from typing import Dict, List, Optional

FLOOD_ROLES: Dict[str, Dict] = {
    "government": {
        "allowed_skills": ["increase_subsidy", "decrease_subsidy", "maintain_subsidy", "outreach"],
        "can_read_state": ["community", "type", "spatial"],
        "can_modify": ["subsidy_rate", "mg_priority", "budget"],
        "artifact_type": "PolicyArtifact",
    },
    "insurance": {
        "allowed_skills": ["raise_premium", "lower_premium", "maintain_premium"],
        "can_read_state": ["community", "type"],
        "can_modify": ["premium_rate", "payout_ratio", "risk_pool"],
        "artifact_type": "MarketArtifact",
    },
    "household": {
        "allowed_skills": [
            "buy_insurance", "buy_contents_insurance", "elevate_house",
            "relocate", "do_nothing", "buyout_program",
        ],
        "can_read_state": ["neighbors", "community"],
        "can_modify": ["elevated", "has_insurance", "relocated"],
        "artifact_type": "HouseholdIntention",
    },
}

@dataclass
class PermissionResult:
    allowed: bool
    reason: str = ""

class RoleEnforcer:
    def __init__(self, roles: Optional[Dict[str, Dict]] = None):
        self.roles = roles or FLOOD_ROLES

    def check_skill_permission(self, agent_type: str, skill: str) -> PermissionResult: ...
    def check_state_access(self, agent_type: str, scope: str) -> PermissionResult: ...
    def check_state_mutation(self, agent_type: str, field: str) -> PermissionResult: ...
```

## Test File: `tests/test_drift_detector.py` (NEW)

Write tests for:
1. `compute_shannon_entropy()` — uniform distribution returns 0, diverse returns > 0, known value check
2. `record_population_snapshot()` + `detect_population_drift()` — echo chamber detection (>80% same)
3. `record_agent_decision()` + `compute_jaccard_similarity()` — stagnant agent (all same) = high score
4. `detect_individual_drift()` — stagnation flag when jaccard > threshold
5. `get_alerts()` — returns warnings for low entropy and individual stagnation
6. `RoleEnforcer.check_skill_permission()` — allowed and denied cases
7. `RoleEnforcer.check_state_access()` — scope enforcement
8. `RoleEnforcer.check_state_mutation()` — field enforcement
9. Empty input edge cases (no snapshots, no history)

## DO NOT

- Do NOT modify any existing file
- Do NOT import from 058-A (artifacts) — drift detector is independent
- Do NOT touch `observable_state.py` (that's 058-E)

## Verification

```bash
pytest tests/test_drift_detector.py -v
```

---

## Completion (Codex)

- Status: ✅ Completed
- Commit: `f40b6bb`
- Tests: `pytest tests/test_drift_detector.py -v`

### Files Added
- `broker/components/drift_detector.py`
- `broker/components/role_permissions.py`
- `tests/test_drift_detector.py`
